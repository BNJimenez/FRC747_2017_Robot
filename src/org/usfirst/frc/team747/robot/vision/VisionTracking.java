package org.usfirst.frc.team747.robot.vision;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfPoint;
import org.opencv.core.Rect;
import org.opencv.imgproc.Imgproc;

import edu.wpi.first.wpilibj.vision.VisionPipeline;

/**
 * VisionTracking class.
 *
 * <p>
 * An OpenCV pipeline generated by GRIP.
 *
 * @author GRIP
 */
public class VisionTracking implements VisionPipeline {
    
    GripPipeline pipe = new GripPipeline();

	// Bounding rectangles should be made of > 60% of the paired contours
    private static final double BOUNDING_AREA_MINIMUM_FILL = .60;
    private static final double BOUNDING_AREA_MINIMUM_SIZE = 100;
    
    private ArrayList<MatOfPoint> contours = new ArrayList<MatOfPoint>();
    
    private final CameraSpecs cameraSpecs;
    private final Map<String, TargetTemplate> targetTemplates;
    public Map<String, Target> targets;
    
    static {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
    }
    
    public VisionTracking(CameraSpecs cameraSpecs, Map<String, TargetTemplate> targetTemplates) {
    	this.cameraSpecs = cameraSpecs;
    	this.targetTemplates = targetTemplates;
    }

    /**
     * This is the primary method that runs the entire pipeline and updates the
     * outputs.
     */
    @Override
    public void process(Mat source0) {
        
        this.pipe.process(source0);
        
        contours = pipe.filterContoursOutput();
        analyzeCoutours(contours);
      }

    /**
     * Analyze Contours for matching.
     *
     * @param contours
     *            Input contours for
     */
    public void analyzeCoutours(ArrayList<MatOfPoint> contours) {
        Map<String, ArrayList<Rect>> buckets = new HashMap<String, ArrayList<Rect>>();
        Map<String, Target> resultTargets = new HashMap<String, Target>();

        for (String key : this.targetTemplates.keySet()) {
            ArrayList<Rect> list = new ArrayList<Rect>();
            buckets.put(key, list);
        }

        for(MatOfPoint contour : contours) {
            Rect rect = Imgproc.boundingRect(contour);
            if (rect.area() > BOUNDING_AREA_MINIMUM_SIZE) {
	            for (String key : this.targetTemplates.keySet()) {
	                if (this.targetTemplates.get(key).isSector(rect)) {
	                    buckets.get(key).add(rect);
	                }
	            }
	        }

            // Attempt partial Matching of two contour, to account for obstructions (Peg, Fuel, Gears)
            for(MatOfPoint contour2: contours) {
                if (contour == contour2) {
                    continue;
                }
                Rect rect2 = Imgproc.boundingRect(contour2);
                int right = Math.min(rect.x, rect2.x);
                int top = Math.min(rect.y, rect2.y);
                int left = Math.max(rect.x + rect.width, rect2.x + rect2.width);
                int bottom = Math.max(rect.y + rect.height, rect2.y + rect2.height);

                Rect bounding = new Rect(right, top, left - right, bottom - top);
                
                // Only test bounding rectangles of the parts make up the minimum area.
                if (bounding.area() > BOUNDING_AREA_MINIMUM_SIZE && rect.area() + rect2.area() > bounding.area() * BOUNDING_AREA_MINIMUM_FILL) {
	                for (String key : this.targetTemplates.keySet()) {
	                    if (this.targetTemplates.get(key).isSector(bounding)) {
	                        buckets.get(key).add(bounding);
	                    }
	                }
                }
            }
        }

        for (String key : buckets.keySet()) {
            ArrayList<Rect> bucket = buckets.get(key);
            Target t = null;

            for (Rect c1 : bucket) {
                for (Rect c2 : bucket) {
                    t = this.targetTemplates.get(key).getTarget(c1, c2, this.cameraSpecs);
                    if (t != null) {
                        resultTargets.put(key, t);
                        break;
                    }
                }
                if (t != null) {
                    break;
                }
            }
        }

        this.targets = resultTargets;
    }

    /**
     * Test if vision tracking has found a target.
     *
     * @return boolean If vision tracking has detected a target.
     */
    public Target getTarget(String name) {
        if (this.targets != null) {
            return this.targets.get(name);
        }
        return null;
    }
}
