package org.usfirst.frc.team747.robot.vision;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfPoint;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;
import org.opencv.imgproc.Imgproc;

import edu.wpi.first.wpilibj.vision.VisionPipeline;

/**
 * VisionTracking class.
 *
 * <p>
 * An OpenCV pipeline generated by GRIP.
 *
 * @author GRIP
 */
public class VisionTracking implements VisionPipeline {

	// Bounding rectangles should be made of > 60% of the paired contours
    private static final double BOUNDING_AREA_MINIMUM_FILL = .70;
    private static final double BOUNDING_AREA_MINIMUM_SIZE = 200;
    
    private Mat hslThresholdOutput = new Mat();
    private Mat desaturateOutput = new Mat();
    private ArrayList<MatOfPoint> findContoursOutput = new ArrayList<MatOfPoint>();
    
    private final CameraSpecs cameraSpecs;
    private final Map<String, TargetTemplate> targetTemplates;
    public Map<String, Target> targets;
    
    static {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
    }
    
    public VisionTracking(CameraSpecs cameraSpecs, Map<String, TargetTemplate> targetTemplates) {
    	this.cameraSpecs = cameraSpecs;
    	this.targetTemplates = targetTemplates;
    }

    /**
     * This is the primary method that runs the entire pipeline and updates the
     * outputs.
     */
    @Override
    public void process(Mat source0) {
        // Step HSL_Threshold0:
        Mat hslThresholdInput = source0;
        double[] hslThresholdHue = {20.0, 139.0};
        double[] hslThresholdSaturation = {0.0, 255.0};
        double[] hslThresholdLuminance = {23.0, 255.0};
        hslThreshold(hslThresholdInput, hslThresholdHue, hslThresholdSaturation, hslThresholdLuminance, hslThresholdOutput);

        // Step Desaturate0:
        Mat desaturateInput = hslThresholdOutput;
        desaturate(desaturateInput, desaturateOutput);

        // Step Find_Contours0:
        Mat findContoursInput = desaturateOutput;
        boolean findContoursExternalOnly = false;
        findContours(findContoursInput, findContoursExternalOnly, findContoursOutput);
        analyzeCoutours(findContoursOutput);
      }

    /**
     * Segment an image based on hue, saturation, and luminance ranges.
     *
     * @param input
     *            The image on which to perform the HSL threshold.
     * @param hue
     *            The min and max hue
     * @param sat
     *            The min and max saturation
     * @param lum
     *            The min and max luminance
     * @param output
     *            The image in which to store the output.
     */
    private void hslThreshold(Mat input, double[] hue, double[] sat, double[] lum, Mat out) {
        Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HLS);
        Core.inRange(out, new Scalar(hue[0], lum[0], sat[0]), new Scalar(hue[1], lum[1], sat[1]),
                        out);
    }

    /**
     * Converts a color image into shades of grey.
     * 
     * @param input
     *            The image on which to perform the desaturate.
     * @param output
     *            The image in which to store the output.
     */
    private void desaturate(Mat input, Mat output) {
        switch (input.channels()) {
        case 1:
            // If the input is already one channel, it's already desaturated
            input.copyTo(output);
            break;
        case 3:
            Imgproc.cvtColor(input, output, Imgproc.COLOR_BGR2GRAY);
            break;
        case 4:
            Imgproc.cvtColor(input, output, Imgproc.COLOR_BGRA2GRAY);
            break;
        default:
            throw new IllegalArgumentException("Input to desaturate must have 1, 3, or 4 channels");
        }
    }

    /**
     * Sets the values of pixels in a binary image to their distance to the
     * nearest black pixel.
     * 
     * @param input
     *            The image on which to perform the Distance Transform.
     * @param type
     *            The Transform.
     * @param maskSize
     *            the size of the mask.
     * @param output
     *            The image in which to store the output.
     */
    private void findContours(Mat input, boolean externalOnly, List<MatOfPoint> contours) {
        Mat hierarchy = new Mat();
        contours.clear();
        int mode;
        if (externalOnly) {
            mode = Imgproc.RETR_EXTERNAL;
        } else {
            mode = Imgproc.RETR_LIST;
        }
        int method = Imgproc.CHAIN_APPROX_SIMPLE;
        Imgproc.findContours(input, contours, hierarchy, mode, method);
    }

    /**
     * Analyze Contours for matching.
     *
     * @param contours
     *            Input contours for
     */
    public void analyzeCoutours(ArrayList<MatOfPoint> contours) {
        Map<String, ArrayList<Rect>> buckets = new HashMap<String, ArrayList<Rect>>();
        Map<String, Target> resultTargets = new HashMap<String, Target>();

        for (String key : this.targetTemplates.keySet()) {
            ArrayList<Rect> list = new ArrayList<Rect>();
            buckets.put(key, list);
        }

        for(MatOfPoint contour : contours) {
            Rect rect = Imgproc.boundingRect(contour);
            if (rect.area() > BOUNDING_AREA_MINIMUM_SIZE) {
	            for (String key : this.targetTemplates.keySet()) {
	                if (this.targetTemplates.get(key).isSector(rect)) {
	                    buckets.get(key).add(rect);
	                }
	            }
	        }

            // Attempt partial Matching of two contour, to account for obstructions (Peg, Fuel, Gears)
            for(MatOfPoint contour2: contours) {
                if (contour == contour2) {
                    continue;
                }
                Rect rect2 = Imgproc.boundingRect(contour2);
                int right = Math.min(rect.x, rect2.x);
                int top = Math.min(rect.y, rect2.y);
                int left = Math.max(rect.x + rect.width, rect2.x + rect2.width);
                int bottom = Math.max(rect.y + rect.height, rect2.y + rect2.height);

                Rect bounding = new Rect(right, top, left - right, bottom - top);
                
                // Only test bounding rectangles of the parts make up the minimum area.
                if (bounding.area() > BOUNDING_AREA_MINIMUM_SIZE && rect.area() + rect2.area() > bounding.area() * BOUNDING_AREA_MINIMUM_FILL) {
	                for (String key : this.targetTemplates.keySet()) {
	                    if (this.targetTemplates.get(key).isSector(bounding)) {
	                        buckets.get(key).add(bounding);
	                    }
	                }
                }
            }
        }

        for (String key : buckets.keySet()) {
            ArrayList<Rect> bucket = buckets.get(key);
            Target t = null;

            for (Rect c1 : bucket) {
                for (Rect c2 : bucket) {
                    t = this.targetTemplates.get(key).getTarget(c1, c2, this.cameraSpecs);
                    if (t != null) {
                        resultTargets.put(key, t);
                        break;
                    }
                }
                if (t != null) {
                    break;
                }
            }
        }

        this.targets = resultTargets;
    }

    /**
     * Test if vision tracking has found a target.
     *
     * @return boolean If vision tracking has detected a target.
     */
    public Target getTarget(String name) {
        if (this.targets != null) {
            return this.targets.get(name);
        }
        return null;
    }
}
